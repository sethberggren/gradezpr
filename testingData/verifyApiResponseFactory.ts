import { default as request } from "supertest";
import { ObjectTyped } from "object-typed";
import app from "../src/app";
import {
  AuthCredentials,
  HTTPMethods,
  tokenHeader,
} from "./addtionalTestInformation";
import { verify } from "jsonwebtoken";
import { string } from "io-ts";

export type VerifyApiResponseOptions<K extends Object> =
  | {
      verifyOpt: "CODE";
      httpCode?: number;
    }
  | {
      verifyOpt: "TYPE";
      desiredResponse: K;
      httpCode?: number;
    }
  | {
      verifyOpt: "BODY";
      desiredResponse: K;
      httpCode?: number;
    };

const verifyObjectType = (actual: Object, desired: Object) => {
  for (const key of ObjectTyped.keys(desired)) {
    expect(actual).toHaveProperty(key);

    const desiredValue = desired[key];
    const desiredType = typeof desiredValue;

    const actualValue = actual[key];
    const actualType = typeof actualValue;

    if (desiredType === "object") {
      verifyObjectType(actualValue, desiredValue);
    } else {
      expect(actualType).toBe(desiredType);
    }
  }
};

const verifyResponseCode = (response: request.Response, httpCode?: number) => {
  if (httpCode) {
    expect(response.statusCode).toBe(httpCode);
  } else {
    expect(response.statusCode).toBe(200);
  }
};

function verifyApiResponse<K extends Object>(
  response: request.Response,
  opts: VerifyApiResponseOptions<K>
): K {
  const { verifyOpt, httpCode } = opts;

  const apiData = response.body;

  if (verifyOpt === "TYPE") {
    verifyObjectType(apiData, opts.desiredResponse);
  } else if (verifyOpt === "BODY") {
    const desiredResponse = opts.desiredResponse;

    // check if the desired response has the id property, and replace that with the id property from the api data response
    // this is because ids are automatically generated by the database

    if (Object.keys(opts.desiredResponse).includes("id")) {
      console.log("replacing id...");
      desiredResponse["id" as keyof typeof desiredResponse] = apiData["id"];

      console.log(desiredResponse);
    };

    expect(JSON.parse(JSON.stringify(apiData))).toStrictEqual(
      JSON.parse(JSON.stringify(opts.desiredResponse))
    );
  }

  verifyResponseCode(response, httpCode);

  return apiData as K;
}

export function verifyApiResponseFactory(
  url: string,
  httpMethod: "GET" | "DELETE",
  authentication?: AuthCredentials
): <K extends Object>(opts: VerifyApiResponseOptions<K>) => Promise<K>;

export function verifyApiResponseFactory(
  url: string,
  httpMethod: "POST" | "PATCH" | "PUT",
  authentication?: AuthCredentials
): <K extends Object>(requestPayload: Object, opts: VerifyApiResponseOptions<K>) => Promise<K>;

export function verifyApiResponseFactory(
  url: string,
  httpMethod: HTTPMethods,
  authentication?: AuthCredentials
):
  | (<K extends Object>(opts: VerifyApiResponseOptions<K>) => Promise<K>)
  | (<K extends Object>(requestPayload: Object, opts: VerifyApiResponseOptions<K>) => Promise<K>) {
  switch (httpMethod) {
    case "DELETE": {
      return async <K extends Object>(opts: VerifyApiResponseOptions<K>) => {
        const header = await tokenHeader(authentication);
        const response = await request(app)
          .delete(url)
          .set(header)
          .expect("Content-Type", /json/);

        return verifyApiResponse<K>(response, opts);
      };
    }

    case "GET": {
      return async <K extends Object>(opts: VerifyApiResponseOptions<K>) => {
        const header = await tokenHeader(authentication);
        const response = await request(app)
          .get(url)
          .set(header)
          .expect("Content-Type", /json/);

        return verifyApiResponse<K>(response, opts);
      };
    }

    case "POST": {
      return async <K extends Object>(
        requestPayload: Object,
        opts: VerifyApiResponseOptions<K>
      ) => {
        const header = await tokenHeader(authentication);
        const response = await request(app)
          .post(url)
          .set(header)
          .send(requestPayload)
          .expect("Content-Type", /json/);

        return verifyApiResponse<K>(response, opts);
      };
    }

    case "PATCH": {
      return async <K extends Object>(
        requestPayload: Object,
        opts: VerifyApiResponseOptions<K>
      ) => {
        const header = await tokenHeader(authentication);
        const response = await request(app)
          .patch(url)
          .set(header)
          .send(requestPayload)
          .expect("Content-Type", /json/);

          return verifyApiResponse<K>(response, opts);
        }
      };

    case "PUT": {
      return async <K extends Object>(
        requestPayload: Object,
        opts: VerifyApiResponseOptions<K>
      ) => {
        const header = await tokenHeader(authentication);
        const response = await request(app)
          .put(url)
          .set(header)
          .send(requestPayload)
          .expect("Content-Type", /json/);

          return verifyApiResponse<K>(response, opts);
        }
      };
    }
};